Linee guida per applicazione di test per XGUI
=============================================

* Sviluppare la stessa applicazione in C++ e Python.

Applicazione che crei una finestra contenente un menu' dal quale
scegliere il test da effettuare: ogni widget avra' il relativo test.

Scelto un widget nella parte centrale della finestra verra' visualizzato posto il widget,
eventualmente di fianco ad un widget List con l'elenco modificabile delle proprieta'.

Prevedere bottoni (o altro) per richiamare i metodi supportati dal widget.

Ogni evento supportato dal widget dovra' essere gestito e inviato come messaggio
di debug nella finestra del terminale.

Testare TUTTI i metodi, proprieta' ed eventi di un widget! 
Anche quelli derivati dalle sue classi genitore!

* Sviluppare una applicazione (in C++ e Python) che carichi un'interfaccia via XML.

Fare in modo che la applicazione carichi TUTTI i widget base impostando TUTTE le loro
proprieta' base, ereditate e di inizializzazione.

Per i widget che hanno uno StyleManager (tipo List e Tree) assegnarne uno caricato da un
altro file XML. Definire vari stili che settino TUTTE le proprieta' di stile possibile.

Per i widget che hanno un Model (tipo List e Tree) testare sia l'assegnazione del modello
caricandolo da un file XML esterno, sia la scrittura del modello all'interno della classe.


* Altro

!!! LE APPLICAZIONI CREATE DEVONO FUNZIONARE IN MANIERA UGUALE SIA SOTTO WINDOWS CHE LINUX !!!


===============
== TEST PLAN ==
===============

C++

STEP 1 - Creazione applicazione C++ che carichi XGUI e apra una finestra standard.
	Test target:
		- funzioni del Master di inizializzazione e finalizzazione della libreria.
		- funzioni del Master per creazione finestra top level
		- funzioni del Master per gestione del loop di eventi
		- funzionamento del loop modale

	Note:
		- testare le proprieta' text, size, position, resizable, border e icon sia 
		  PRIMA che DOPO l'invocazione del metodo show(), in due compilazioni 
		  successive del programma. Appurato che funzionino entrambe allo stesso modo
		  lasciarne solo una delle due.

STEP 2 - Creazione di un introspettore delle classi
	Test target:
		- Controllo caricamento plugin esterni da dialog per apertura file
		- controllo disponibilità delle proprietà
		- funzionamento dell'impostazione di proprietà
		- funzionamento del recupero del valore di una proprietà su un message dialog
		- funzionamento delle chiamate dinamiche
		- creazione e distruzione dinamica di oggetti

STEP 3 - Caricamento e salvataggio XML con DTD
	Test target:
		- Controllo correttezza nella generazione della DTD
		- Controllo correttezza nell'analisi dell'xml
		- Controllo correttezza assegnamento di proprietà via xml
		- Controllo correttezza nell'assegnamento di stili e modelli caricati via xml
		- Controllo funzionalità di DUMP degli oggetti in xml con dialog salvataggio file

	Note:
		- Editor di interfacce. Al termine dello step 3 si dovrebbe avere uno strumento
		  in grado di generare l'xml descrittivo di un'interfaccia unendo le 
		  funzionalità dello step 2 e step 3

STEP 4 - Test python con threads
	Test target:
		- Controllo funzionamento del mainloop abbinato a thread in python
		- Controllo funzionamento degli event handler in ambiente multithreaded in python
		- Controllo funzionamento della callback di idle in multithreading in python
		- Controllo funzionamento del loop modale in ambiente multithreaded

STEP 5 - Test sistema dinamico con python
	Test target:
		- Controllare la correttezza delle chiamate di funzione dinamiche in python
		- Controllare funzionamento della costruzione di oggetti python da plugin c++
		- Controllare il funzionamento delle chiamate dinamiche su plugin c++ da python

